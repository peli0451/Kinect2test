\subsection{Ergänzungen zum Zusammenspiel und Ablaufskizze}
In diesem Abschnitt wird der Ablauf des Programms skizziert. Wir gehen dabei davon aus, dass KinectControl bereits instanziiert und durch Aufruf der init()-Funktion initialisiert wurde. Wir stellen uns weiter vor, dass die run()-Methode im Main-Loop der umgebenden Software ausgeführt wird. Genaueres zur Einbindung ist Abschnitt \ref{sec:einbinden} zu entnehmen.\par 
Sollte kein Master bestimmt sein, so werden für den Master zunächst eindeutige Defaultwerte für ID und Entfernung zur Kamera (genauer: auf der $z$-Achse) angenommen.\par 
Wir versuchen dann, über den BodyFrameReader der Kinect, einen aktuellen Kinect-Frame abzugreifen. Sollte dies fehlschlagen, so werden die alten Bewegungsparameter einfach weiterverwendet. Im Falle des Erfolgs versuchen wir auf die Körpertracking-daten der Kinect zuzugreifen, was im Fehlerfall analog behandelt wird. Gerade die erste Art von Fehlschlag tritt dabei tatsächlich häufig ein, da die Kinect nur etwa 30 Frames pro Sekunde liefern, wohingegen der Tick des Main Loops überlicherweise deutlich darüber liegt.\par 
Wir gehen den weiteren Programmablauf nun zunächst dafür durch, dass kein Master eingespeichert wird oder wurde. In diesem Falle ist der nächste relevante Schritt das Iterieren über die Körper, die die Kinect zurückgeliefert hat. Dabei holen wir uns die genauen Körperdaten: Die Positionen und Orientierungen der Gelenke. In der genannten Situation (vor jeglicher Masterfestlegung) verwenden wir den primitiven $z$-Test zur Festlegung einer Person, die das Programm steuert. Dazu wird das Master-Objekt einfach mit den Werten des Körpers belegt, dessen Kopf den niedrigsten $z$"=Wert aufweist. Im Programm schließt sodann die Steuerung an.\par 
Wenden wir uns zunächst aber noch den anderen Fällen zu: Das Programmverhalten ändert sich, wenn durch Betätigen der Einspeichertaste X ein Master festgelegt werden soll. Eine entsprechende Abfrage im Main-Loop des unterliegenden Programmes ruft die assignMaster()-Funktion von KinectControl auf, die die für die Masterfestlegung wichtigen Parameter initialisiert. Vor allem wwerden die booleschen Variablen masterDetermined und collectFrames auf true gesetzt und je nach Länge des Tastendrucks eine Variable hochgezählt, die die Anzahl der Samples für die Vermessung bestimmt. Fall zwei bei der Masterbehandlung entspricht dann der Belegung der beiden Variablen masterDetermined und collectFrames mit true. In diesem Falle wird bei der Iterierung über die Körper zunächst ein Körper in Standardpose gesucht, der der Master werden soll und die ID gespeichert. Nachdem diese ID festgelegt ist, werden solange Körpermerkmale gesammelt, wie durch den Framezähler aus assignMaster() vorgegeben. Dazu rufen wir die collectBodyProperties()-Funktion aus der Person-Klasse auf, die wie gesagt ein festes Set an Körpermerkmalen puffert. Sollte der designierte Master dabei die Standardpose verlassen, wir die bisherige Sammlung mittels deleteCollectedBodyProperties verworfen und die ID-Festlegung vom Anfang erneut durchgeführt. War der Frame hingegen gut, wird die Anzahl noch zu sammelnder Frames dekrementiert. Sind genau so viele Frames gesammelt, wie assignMaster() festgelegt hat, so wird die Masterfestlegung durch Rücksetzen von collectFrames und Aufruf von calculateBodyProperties() (ebenfalls aus der Person-Klasse) beendet. Konzeptuell erstellt letztere Funktion aus den vorher gesammelten Daten einen charakteristischen Vektor für die eingespeicherte Person, den sie im Master-Objekt ablegt.\par 
Der dritte Fall in Sachen Masterfestlegung schließt sich sodann an, wenn also ein Master bestimmt wurde (masterDetermined ist true), jedoch keine Samples mehr gesammelt werden müssen (collectFrames ist false). Dann muss nur etwas getan werden, falls der Master zwischenzeitlich aus dem Tracking verschwunden ist, was vor der Iteration über die Körper überprüft wird. In diesem Falle wird searchForMaster gesetzt. Für die 0-1-Flanke von searchForMaster wird ein spezielles lostMaster-Flag gesetzt.