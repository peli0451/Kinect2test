\subsection{Zustandsmaschine}\label{sec:statemachine}
In der folgenden Abbildung ist die Zustandsmaschine des Programmes zu sehen. Im Weiteren wird auf die Zustände und ihre Übergänge eingegangen.
\begin{figure}[H]
	\centering
	\input{pictures/statemachine}
	\caption{Die Zustandsmaschine. Die Beschriftungen T, R, G, F und U stehen für die verschiedenen Gesten aus Abschnitt \ref{sec:gesten}: (T)RANSLATE\_GESTURE, (R)OTATE\_GESTURE, (G)RAB\_GESTURE, (F)LY\_GESTURE und schließlich (U)NKNOWN\_GESTURE.}\label{fig:sm}
	\end{figure}	
	Das Programm besteht aus zwei Grundmodi der Manipulation: Einerseits der Manipulation der Kamera und andererseits jener des Objekts. Diese beiden Modi können als zwei Superzustände aufgefasst werden, innerhalb derer sich wiederum unterscheidet, auf welche Art und Weise manipuliert. Die Zustandsmaschine dient einerseits der Kapselung und Modularisierung der vom entstehenden Programm bereitgestellten Funktionen und bildet andererseits die Struktur der Manipulationsmodi abstrakt ab.\par 
	Die Zustandsmaschine befindet sich zu jedem Zeitpunkt in einem Zustand. In diesem Zustand findet eine Berechnung der Parameter statt, die das Programm zurückgibt. Diese Parameter beschreiben wiederum die Manipulation, die ausgeführt werden soll. Dies geschieht durch Auswertung der gesehenen Geste und die Berechnung entscheidender Größen, u.\,U. unter Einbeziehung der Werte vergangener Frames. Schließlich erfolgt basierend auf der präsentierten Geste ein Zustandswechsel am Ende eines Berechnungsschritts.\par 
	Im Folgenden sind die Zustände erklärt, ihre Semantik und die enthaltenen Berechnungen (vgl. dazu auch wieder Abbildung \ref{fig:sm}):
	\begin{description}
		\item[IDLE] Dieser Zustand entspricht dem Initialzustand der Zustandsmachine. Er ist eine Art Default-Zustand, in dem keine Kamera- und auch keine Objektmanipulation (genauer: keine Berechnung überhaupt) vorgenommen wird. Der Zustand wird betreten, wenn keine der vordefinierten Gesten sicher genug erkannt wurde. Durch Ausführung der entsprechenden Gesten gelangt der Benutzer zurück in die anderen Zustände.
		\item[CAMERA\_TRANSLATE] Dieser Zustand gehört zur Kameramanipulation. In ihm werden gemäß der oben erklärten Geste die Parameter zur Kamerabewegung bestimmt. Ziel ist die direkte Übertragung der Handbewegungen des Benutzers auf die Kamerabewegung, die im lokalen Raum der Kamera stattfindet. Dazu wird aus den gepufferten Positionswerten von linker und rechter Hand die diskrete Ableitung berechnet, die ein Maß für die Geschwindigkeit der Bewegung liefert. Ebenso ergiebt sich daraus die Richtung, in die die Hände bewegt wurden. Die Geschwindigkeit wird dann mit der vergangenen Zeit zwischen dem aktuellen und dem vorhergehenden Frame multipliziert, um wieder einen Entfernungswert zu erhalten. Daraus entstehen die Translationsparameter für die $x$"=, $y$"= und $z$"=Richtungen, die für diesen Zustand die Rückgabeparameter definieren.
		\item[CAMERA\_ROTATE] Dieser Zustand gehört ebenfalls zur Kameramanipulation. Analog zu oben wird hier die Rotation vorbereitet. Die Rotation ist konzeptionell nahe der Translation. Während die Geste aktiv ist, wird eine Achse zwischen linker und rechter Hand des Benutzers bestimmt. Bewegt der Benutzer die Hände, so verändert sich die Achse. Ein Quaternion, der die Achsen ineinander überführt, wird berechnet, und analog zur Translation als Geschwindigkeit interpretiert. Dieser wird proportional zur verstrichenen Zeit zum vorhergegangenen Frame verkleinert und auf die Kamerarotation angewandt.
		\item[OBJECT\_MANIPULATE] Die Objektmanipulation realisiert das einhändige Packen eines virtuellen Objektes mit einer einzigen Hand. Dabei werden Aspekte der Translation und Rotation abgewandelt verwendet. Die Bewegung der packenden Hand wird sehr ähnlich zur Kamera-Translation direkt übertragen. Im Gegensatz zu CAMERA\_TRANSLATE wird diese allerdings auf das Objekt angewandt. Außerdem soll jede Rotation der packenden Hand auf das Objekt übertragen werden. Dazu wird Kinect::JointOrientation genutzt, welches die Orientierung der Hand im Raum als Quaternion bereitstellt. Es wird eine Art Differenz zwischen der Orientierung eines Frames und den gepufferten Vorgängerorientierungen gebildet. Dies findet statt, indem die Vorgängerorientierungen invertiert auf die aktuelle Orientierung angewandt werden. Wie zuvor kann diese Differenz als Geschwindigkeit interpretiert werden. Bei der Anwendung auf das Objekt muss jedoch beachtet werden, dass eine Drehung der Hand beispielsweise um ihre $z$-Achse nicht unweigerlich auch einer Drehung des Objektes um dessen $z$-Achse haben soll. Für natürliches Verhalten muss die Rotation selbst noch abhängig von Objekt- sowie Kamerarotation gedreht werden.
		\item[FLY] Dieser Zustand wurde nachträglich eingeführt, als die Notwendigkeit eines Flug-Modus deutlich wurde. Er wird mittels Vorführung der FLY"=Geste betreten und analog zu den anderen Zuständen verlassen. Der Flugmodus soll eine durchgehende Bewegung realisieren, ohne dass der Benutzer sich permanent bewegt. Sie bildet primär eine Alternative zum wiederholten Anwenden von CAMERA\_TRANSLATE. Während die Geste aktiv ist, wird eine Translation mit festen Werten nach vorn vorgenommen. Außerdem ist es möglich, durch die Neigung der nach vorn gestreckten Arme zu lenken. Dazu wird die mittlere Handposition mit einem Referenzpunkt auf dem Körper des Benutzers verglichen. Die Abweichung der Position von einer neutralen Ausgangsposition bestimmt die Lenkrichtung. Die Stärke der Auslenkung bestimmt dabei die Stärke der Rotation. Um schnellere Drehungen zu gewährleisten, werden starke Auslenkungen noch zusätzlich verstärkt. Analog zur CAMERA\_ROTATE wird ein Quaternion berechnet, welcher die neutrale Position auf die gegebene Position abbildet. Er wird wie üblich angewandt. Außerdem wird die Neigung der Achse von linker Schulter zu rechter Schulter bestimmt. Diese wird in eine kontinuierliche Seitwärtsrolle übersetzt.
	\end{description}
	Zur Verdeutlichung sei darauf hingewiesen, dass von jedem Zustand zu jedem anderen übergegangen werden kann, wobei dieser Übergang lediglich anhand erkannter Gesten erfolgt: Wird eine der Gesten erkannt (Details siehe Abschnitt \ref{sec:robustheit}), so wird der zugehörige Zustand betreten. Da das Programm darauf ausgelegt ist, während des Event-Loops einer Hauptanwendung zu laufen, besteht die Zustandsmaschine ab ihres Starts permanent (bzw. bis zum Ende der Hauptanwendung) und besitzt keinen Finalzustand. Genaueres zum Aussehen der State-Machine als Datenstruktur ist in Abschnitt \ref{sec:ds} zu finden.

